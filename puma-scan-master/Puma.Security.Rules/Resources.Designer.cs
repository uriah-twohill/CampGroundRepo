//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Puma.Security.Rules {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Puma.Security.Rules.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to None.
        /// </summary>
        internal static string Analyzer_Category_None {
            get {
                return ResourceManager.GetString("Analyzer_Category_None", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Security.
        /// </summary>
        internal static string Analyzer_Category_Security {
            get {
                return ResourceManager.GetString("Analyzer_Category_Security", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Syntax.
        /// </summary>
        internal static string Analyzer_Category_Syntax {
            get {
                return ResourceManager.GetString("Analyzer_Category_Syntax", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0001-debug-build-enabled.
        /// </summary>
        internal static string Analyzer_SEC0001_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0001_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries compiled in debug mode can leak detailed stack traces and debugging messages to attackers. Disable debug builds by setting the debug attribute to false..
        /// </summary>
        internal static string Analyzer_SEC0001_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0001_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Debug compilation is enabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0001_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0001_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Debug Build Enabled.
        /// </summary>
        internal static string Analyzer_SEC0001_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0001_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0002-custom-errors-disabled.
        /// </summary>
        internal static string Analyzer_SEC0002_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0002_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Displaying stack traces in the browser can leak information to attackers and help them gain information for launching additional attacks. Enable custom errors by setting the mode to On or RemoteOnly: &lt;customErrors mode=&quot;On|RemoteOnly&quot; /&gt;..
        /// </summary>
        internal static string Analyzer_SEC0002_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0002_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom errors are disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0002_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0002_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Custom Errors Disabled.
        /// </summary>
        internal static string Analyzer_SEC0002_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0002_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0003-forms-authentication-insecure-cookie.
        /// </summary>
        internal static string Analyzer_SEC0003_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0003_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Authentication cookies sent over HTTP connections can be stolen by attackers monitoring the network traffic, which can lead to session hijacking attacks. Configure &quot;secure&quot; cookies by setting the requireSSL attribute to true..
        /// </summary>
        internal static string Analyzer_SEC0003_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0003_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms authentication does not set requireSSL to true. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0003_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0003_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication Secure Cookie Disabled.
        /// </summary>
        internal static string Analyzer_SEC0003_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0003_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0004-forms-authentication-cookieless-mode.
        /// </summary>
        internal static string Analyzer_SEC0004_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0004_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Authentication cookies should not be sent in the URL. Doing so allows attackers to gain unauthorized access to authentication tokens (web server logs, referrer headers, and browser history) and more easily perform session fixation / hijacking attacks. Configure cookie-base authentication by setting the cookieless attribute to UseCookies..
        /// </summary>
        internal static string Analyzer_SEC0004_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0004_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms authentication does not set the cookieless attribute to UseCookies. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0004_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0004_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication Cookieless Session Enabled.
        /// </summary>
        internal static string Analyzer_SEC0004_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0004_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0005-forms-authentication-cross-app-redirects.
        /// </summary>
        internal static string Analyzer_SEC0005_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0005_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enabling cross-application redirects can allow unvalidated redirect attacks via the returnUrl parameter during the login process. Disable cross-application redirects to by setting the enableCrossAppRedirects attribute to false..
        /// </summary>
        internal static string Analyzer_SEC0005_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0005_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms authentication does not set the enableCrossAppRedirects attribute to false. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0005_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0005_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication CrossAppRedirects Enabled.
        /// </summary>
        internal static string Analyzer_SEC0005_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0005_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0006-forms-authentication-weak-cookie-protection.
        /// </summary>
        internal static string Analyzer_SEC0006_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0006_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication cookies must use strong encryption and message authentication code (MAC) validation to protect the cookie value from inspection and tampering. Configure the forms protection attribute to “All” to enable cookie data validation and encryption..
        /// </summary>
        internal static string Analyzer_SEC0006_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0006_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms authentication cookie protection attribute is not set to All. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0006_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0006_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication Weak Cookie Protection.
        /// </summary>
        internal static string Analyzer_SEC0006_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0006_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0007-forms-authentication-weak-timeout.
        /// </summary>
        internal static string Analyzer_SEC0007_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0007_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Excessive authentication timeout values provide attackers with a large window of opportunity to hijack user’s authentication tokens. Configure the forms timeout value to meet the timeout policy..
        /// </summary>
        internal static string Analyzer_SEC0007_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0007_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms authentication timeout value exceeds the policy of {3} minutes. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0007_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0007_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Forms Authentication Weak Timeout.
        /// </summary>
        internal static string Analyzer_SEC0007_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0007_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0008-header-checking-disabled.
        /// </summary>
        internal static string Analyzer_SEC0008_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0008_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Disabling the HTTP Runtime header checking protection opens the application up to HTTP Header Injection (aka Response Splitting) attacks. Enable the header checking protection by setting the httpRuntime element&apos;s enableHeaderChecking attribute to true, which is the default value..
        /// </summary>
        internal static string Analyzer_SEC0008_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0008_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HTTP header checking is disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0008_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0008_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to HTTP Header Checking Disabled.
        /// </summary>
        internal static string Analyzer_SEC0008_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0008_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0009-version-header-enabled.
        /// </summary>
        internal static string Analyzer_SEC0009_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0009_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Version HTTP response header sends the ASP.NET framework version to the client&apos;s browser. This information can help an attacker identify vulnerabilities in the server&apos;s framework version and should be disabled in production. Disable the version response header by setting the httpRuntime element&apos;s enableVersionHeader attribute to false..
        /// </summary>
        internal static string Analyzer_SEC0009_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0009_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Version HTTP response header is enabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0009_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0009_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Version HTTP Response Header Enabled.
        /// </summary>
        internal static string Analyzer_SEC0009_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0009_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0010-event-validation-disbled.
        /// </summary>
        internal static string Analyzer_SEC0010_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0010_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event validation prevents unauthorized post backs in web form applications. Disabling this feature can allow attackers to forge requests from controls not visible or enabled on a given web form. Enable event validation by setting the page element&apos;s eventValidation attribute to true..
        /// </summary>
        internal static string Analyzer_SEC0010_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0010_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Event validation is disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0010_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0010_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pages EventValidation Disabled.
        /// </summary>
        internal static string Analyzer_SEC0010_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0010_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0011-view-state-mac-disabled.
        /// </summary>
        internal static string Analyzer_SEC0011_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0011_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The ViewStateMac protection prevents tampering with the web forms view state and event validation hidden fields. Disabing this feature can allow attackers to manipluate these fields in the browser and bypass several security features in the .NET framework. Enable the view state mac protection by setting the page element&apos;s viewStateMac attribute to true..
        /// </summary>
        internal static string Analyzer_SEC0011_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0011_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ViewStateMac is disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0011_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0011_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pages ViewStateMac Disabled.
        /// </summary>
        internal static string Analyzer_SEC0011_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0011_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0012-request-validation-disabled.
        /// </summary>
        internal static string Analyzer_SEC0012_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0012_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The ValidateRequest protection performs blacklist input validation for XSS payloads found in form and URL request parameters. Request validation has known bypass issues and does not prevent all XSS attacks, but it does provide a strong countermeasure for most payloads targeting a HTML context. Request validation should be enabled by setting the page element&apos;s requestValidation attribute to true. Then, consider making exceptions or overriding the default behavior on individual request parameters..
        /// </summary>
        internal static string Analyzer_SEC0012_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0012_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Validate request is disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0012_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0012_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pages ValidateRequest Disabled.
        /// </summary>
        internal static string Analyzer_SEC0012_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0012_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0013-view-state-encryption-disabled.
        /// </summary>
        internal static string Analyzer_SEC0013_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0013_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The web forms view state hidden field is base64 encoded by default, which can be easily decoded. Applications placing sensitive data into the view state are vulnerable to information leakage issues via the view state parameter.  The pages ViewStateEncryptionMode attribute allows an application encrypt the view state data with the .NET machine key..
        /// </summary>
        internal static string Analyzer_SEC0013_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0013_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pages ViewStateEncryptionMode disabled. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0013_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0013_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pages ViewStateEncryptionMode Disabled.
        /// </summary>
        internal static string Analyzer_SEC0013_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0013_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0014-insecure-http-cookies.
        /// </summary>
        internal static string Analyzer_SEC0014_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0014_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cookies containing authentication tokens, session tokens, and other state management credentials must be protected in transit across a network. Set the httpCookie element&apos;s requireSSL attribute to true to prevent the browser from transmitting cookies over HTTP..
        /// </summary>
        internal static string Analyzer_SEC0014_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0014_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure HTTP cookies {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0014_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0014_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure HTTP Cookie Transport.
        /// </summary>
        internal static string Analyzer_SEC0014_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0014_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0015-cookies-accessible-via-script.
        /// </summary>
        internal static string Analyzer_SEC0015_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0015_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cookies that do not have the httpOnly attribute set are accessible in the browser by scripts. This can allow attackers to inject malicious scripts into the site and extract authentication cookie values to a remote server. Setting the httpCookie element&apos;s httpOnlyCookies element to true will help prevent client-side session hijacking attempts..
        /// </summary>
        internal static string Analyzer_SEC0015_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0015_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cookies accessible via script. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0015_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0015_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cookie Accessible via Script.
        /// </summary>
        internal static string Analyzer_SEC0015_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0015_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0016-cleartext-machine-key.
        /// </summary>
        internal static string Analyzer_SEC0016_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0016_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The machine key element defines keys to use for encryption and decryption of authentication cookies, view state, and verification of session state identification. The validation and decryption key values should not be stored in configuration files in cleartext. Encrypt the machineKey section of the configuration file using aspnet_regiis.exe..
        /// </summary>
        internal static string Analyzer_SEC0016_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0016_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Machine key element is not encrypted. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0016_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0016_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cleartext Machine Key.
        /// </summary>
        internal static string Analyzer_SEC0016_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0016_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0017-identity-weak-password-complexity.
        /// </summary>
        internal static string Analyzer_SEC0017_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0017_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Identity PasswordValidator settings do not meet the password complexity requirements. Weak passwords can be cracked much faster than complex passwords with sufficient length and complexity requirements..
        /// </summary>
        internal static string Analyzer_SEC0017_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0017_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Password validator settings do not meet the requirements - Minimum Length ({0}), Numeric Character ({1}), Lowercase Character ({2}), Uppercase Character ({3}), Special Character ({4}).
        /// </summary>
        internal static string Analyzer_SEC0017_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0017_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Password Complexity.
        /// </summary>
        internal static string Analyzer_SEC0017_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0017_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0018-identity-password-lockout-disabled.
        /// </summary>
        internal static string Analyzer_SEC0018_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0018_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Identity password lockout feature is disabled. This can allow brute force and dictionary attacks against user accounts. To enable the password lockout feature, set the shouldLockout parameter to true..
        /// </summary>
        internal static string Analyzer_SEC0018_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0018_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Password lockout is disabled. To protect accounts from brute force attacks, set the shouldLockout parameter to true..
        /// </summary>
        internal static string Analyzer_SEC0018_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0018_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identity Password Lockout Disabled.
        /// </summary>
        internal static string Analyzer_SEC0018_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0018_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0019-missing-antiforgery-token-attribute.
        /// </summary>
        internal static string Analyzer_SEC0019_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0019_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The AntiForgeryToken attribute protects applications using authentication cookies from CSRF attacks. Without the AntiForgeryToken attribute, attackers can submit forged requests on behalf of another authenticated user..
        /// </summary>
        internal static string Analyzer_SEC0019_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0019_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Action is missing the AntiForgeryToken attribute. If this action modifies data on the backend, it could be vulnerable to Cross-Site Request Forgery attacks..
        /// </summary>
        internal static string Analyzer_SEC0019_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0019_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing AntiForgeryToken Attribute.
        /// </summary>
        internal static string Analyzer_SEC0019_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0019_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0020-weak-session-timeout.
        /// </summary>
        internal static string Analyzer_SEC0020_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0020_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Excessive authentication timeout values provide attackers with a large window of opportunity to hijack user’s session tokens. Configure the session timeout value to meet your organization&apos;s timeout policy..
        /// </summary>
        internal static string Analyzer_SEC0020_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0020_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session timeout value exceeds the policy of {3} minutes. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0020_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0020_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Session Timeout.
        /// </summary>
        internal static string Analyzer_SEC0020_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0020_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0021-state-server-mode.
        /// </summary>
        internal static string Analyzer_SEC0021_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0021_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The session StateServer mode transports session data insecurely to a remote server. The remote server also does not require system authentication to access the session data for an application. This risk depends entirely on the sensitivity of the data stored in the user&apos;s session. If the session data is considered sensitive, consider adding an external control (e.g. IPSEC) that provides mutual authentication and transport security..
        /// </summary>
        internal static string Analyzer_SEC0021_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0021_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The session mode is set to StateServer. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0021_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0021_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Session State Server Mode.
        /// </summary>
        internal static string Analyzer_SEC0021_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0021_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0022-model-request-validation-disabled.
        /// </summary>
        internal static string Analyzer_SEC0022_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0022_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The request validation protection performs blacklist input validation for XSS payloads found in form and URL request parameters. Request validation has known bypass issues and does not prevent all XSS attacks, but it does provide a strong countermeasure for most payloads targeting a HTML context. Request validation is disabled when using the AllowHtml attribute. This property should have strict white list validation in place to restrict user input..
        /// </summary>
        internal static string Analyzer_SEC0022_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0022_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The AllowHtml attribute disables the validate request security feature..
        /// </summary>
        internal static string Analyzer_SEC0022_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0022_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Model Request Validation Disabled.
        /// </summary>
        internal static string Analyzer_SEC0022_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0022_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0023-action-request-validation-disabled.
        /// </summary>
        internal static string Analyzer_SEC0023_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0023_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The request validation protection performs blacklist input validation for XSS payloads found in form and URL request parameters. Request validation has known bypass issues and does not prevent all XSS attacks, but it does provide a strong countermeasure for most payloads targeting a HTML context. Request validation is disabled when using the [ValidateInput(false)] attribute. This action should have strict white list validation in place to restrict user input..
        /// </summary>
        internal static string Analyzer_SEC0023_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0023_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Setting the ValidateInput method&apos;s first parameter to false disables the validate request security feature..
        /// </summary>
        internal static string Analyzer_SEC0023_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0023_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Action Request Validation Disabled.
        /// </summary>
        internal static string Analyzer_SEC0023_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0023_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0024-unencoded-response-write.
        /// </summary>
        internal static string Analyzer_SEC0024_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0024_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using the raw HttpResponse.Write method. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.). Fixing the vulnerability requires the AntiXssEncoder.HtmlEncode method to neutralize dangous data before writing it to the browser..
        /// </summary>
        internal static string Analyzer_SEC0024_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0024_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw data is passed to the Response.Write method..
        /// </summary>
        internal static string Analyzer_SEC0024_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0024_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unencoded Response Write.
        /// </summary>
        internal static string Analyzer_SEC0024_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0024_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0025-weak-algorithm-des.
        /// </summary>
        internal static string Analyzer_SEC0025_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0025_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The DESCryptoServiceProvider class uses the weak DES algorithm and is not an approved encryption algorithm. Use the AesManaged or AesCryptoServiceProvider algorithm for symmetric encryption..
        /// </summary>
        internal static string Analyzer_SEC0025_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0025_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The DES algorithm is a weak encryption algorithm and not considered secure for protecting sensitive information..
        /// </summary>
        internal static string Analyzer_SEC0025_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0025_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Cryptography Algorithm (DES).
        /// </summary>
        internal static string Analyzer_SEC0025_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0025_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0026-weak-cipher-mode-ecb.
        /// </summary>
        internal static string Analyzer_SEC0026_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0026_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Electronic Codebook (ECB) mode encrypts blocks individually without using an initialization vector. Encrypting data in ECB mode fails to provide entropy for identical plaintext blocks being encrypted with the same encryption key. This can allow attackers to identify patterns and repetition in ciphertext, and may lead to the discovery of the original encryption key. Use the CipherMode.CBC option for symmetric block cipher operations..
        /// </summary>
        internal static string Analyzer_SEC0026_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0026_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Electronic Codebook (ECB) mode is not secure for symmetric block cipher operations..
        /// </summary>
        internal static string Analyzer_SEC0026_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0026_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure Cipher Mode - Electronic Codebook (ECB).
        /// </summary>
        internal static string Analyzer_SEC0026_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0026_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0027-weak-algorithm-md5.
        /// </summary>
        internal static string Analyzer_SEC0027_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0027_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use the SHA256Managed (at least) preferably SHA512Managed for hashing operations. NOTE: SHA2 is still not sufficient for password hashing, which requires a unique salt and adaptive hashing algorithm. See the documentation for secure password hashing advice..
        /// </summary>
        internal static string Analyzer_SEC0027_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0027_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MD5CryptoServiceProvider class uses the weak MD5 algorithm and is not an approved hashing algorithm..
        /// </summary>
        internal static string Analyzer_SEC0027_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0027_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Cryptography Algorithm (MD5).
        /// </summary>
        internal static string Analyzer_SEC0027_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0027_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0028-weak-algorithm-sha1.
        /// </summary>
        internal static string Analyzer_SEC0028_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0028_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider upgrading the algorithm to at least SHA2.Use the SHA256Managed (at least) preferably SHA512Managed for hashing operations. NOTE: SHA2 is still not sufficient for password hashing, which requires a unique salt and adaptive hashing algorithm. See the documentation for secure password hashing advice..
        /// </summary>
        internal static string Analyzer_SEC0028_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0028_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SHA1 algorithm has known collision weaknesses and should no longer be used in a security context..
        /// </summary>
        internal static string Analyzer_SEC0028_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0028_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Weak Cryptography Algorithm (SHA1).
        /// </summary>
        internal static string Analyzer_SEC0028_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0028_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0029-insecure-deserialization.
        /// </summary>
        internal static string Analyzer_SEC0029_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0029_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Deserializing untrusted data using a vulnerable library can allow attackers to execute arbitrary code and perform denial of service attacks against the server.
        ///
        ///Avoid deserializing untrusted data (e.g. request parameters, web service parameters, data from external services) using the above dangerous methods. In cases where deserialization is required, ensure that the application performs signature validation (e.g. HMAC) before deserializing the data..
        /// </summary>
        internal static string Analyzer_SEC0029_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0029_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Deserializing untrusted data with a vulnerable library can result in remote code execution and denial of service vulnerabilities..
        /// </summary>
        internal static string Analyzer_SEC0029_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0029_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure Deserialization.
        /// </summary>
        internal static string Analyzer_SEC0029_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0029_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0030-deserialization-newtonsoft-json.
        /// </summary>
        internal static string Analyzer_SEC0030_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0030_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Newtonsoft JSON DeserializeObject method can allow attackers to execute arbitrary code and perform denial of service attacks if the TypeNameHandling setting is set to a value other than None..
        /// </summary>
        internal static string Analyzer_SEC0030_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0030_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Newtonsoft JSON DeserializeObject method can allow attackers to execute arbitrary code and perform denial of service attacks if the TypeNameHandling setting is set to a value other than None..
        /// </summary>
        internal static string Analyzer_SEC0030_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0030_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure Deserialization - Newtonsoft JSON.
        /// </summary>
        internal static string Analyzer_SEC0030_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0030_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0031-command-injection-process-start.
        /// </summary>
        internal static string Analyzer_SEC0031_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0031_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concatenating untrusted data into operating system commands can allow attackers to execute arbitrary commands against the server&apos;s operating system.
        ///
        ///Defending against command injection in the .NET ecosystem is more difficult than other injection categories because no special encoding method exists to whitelist safe characters and escape evil characters..
        /// </summary>
        internal static string Analyzer_SEC0031_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0031_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is passed to the Process.Start fileName or arguments parameter..
        /// </summary>
        internal static string Analyzer_SEC0031_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0031_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Command Injection Process Start.
        /// </summary>
        internal static string Analyzer_SEC0031_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0031_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0032-command-injection-process-start-info.
        /// </summary>
        internal static string Analyzer_SEC0032_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0032_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concatenating untrusted data into operating system commands can allow attackers to execute arbitrary commands against the server&apos;s operating system.
        ///
        ///Defending against command injection in the .NET ecosystem is more difficult than other injection categories because no special encoding method exists to whitelist safe characters and escape evil characters..
        /// </summary>
        internal static string Analyzer_SEC0032_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0032_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is passed to the ProcessStartInfo fileName or arguments parameter..
        /// </summary>
        internal static string Analyzer_SEC0032_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0032_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Command Injection Process Start Info.
        /// </summary>
        internal static string Analyzer_SEC0032_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0032_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0100-raw-inline-expression.
        /// </summary>
        internal static string Analyzer_SEC0100_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0100_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using a raw write: &lt;%= var %&gt;. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Instead of using a raw write, use the HTML encode inline shortcut (&lt;%: var %&gt;) to automatically HTML encode data before writing it to the browser..
        /// </summary>
        internal static string Analyzer_SEC0100_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0100_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw inline expression writes unencoded data to the HTTP response. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0100_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0100_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw Inline Expression.
        /// </summary>
        internal static string Analyzer_SEC0100_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0100_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0101-raw-binding-expression.
        /// </summary>
        internal static string Analyzer_SEC0101_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0101_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using a raw binding expression: &lt;%# Item.Variable %&gt;. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Instead of using a raw binding expression, use the HTML encoded binding shortcut (&lt;%#: Item.Variable %&gt;) to automatically HTML encode data before writing it to the browser..
        /// </summary>
        internal static string Analyzer_SEC0101_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0101_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw binding expression writes unencoded data to the HTTP response. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0101_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0101_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw Binding Expression.
        /// </summary>
        internal static string Analyzer_SEC0101_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0101_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0102-raw-razor-method.
        /// </summary>
        internal static string Analyzer_SEC0102_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0102_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using a raw Razor helper method: @Html.Raw(Model.Variable). This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Instead of using the raw Razor helper method, use a Razor helper that performs automatic xHTML encoding before writing it to the browser..
        /// </summary>
        internal static string Analyzer_SEC0102_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0102_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw Razor helper method writes unencoded data to the view. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0102_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0102_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw Razor Method.
        /// </summary>
        internal static string Analyzer_SEC0102_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0102_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0103-raw-writeliteral-method.
        /// </summary>
        internal static string Analyzer_SEC0103_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0103_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using the raw WriteLiteral method. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Instead of using the raw WriteLiteral method, use a Razor helper that performs automatic HTML encoding before writing it to the browser..
        /// </summary>
        internal static string Analyzer_SEC0103_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0103_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw WriteLiteral method writes unencoded data to the view. {0}({1}): {2}.
        /// </summary>
        internal static string Analyzer_SEC0103_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0103_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Raw WriteLiteral Method.
        /// </summary>
        internal static string Analyzer_SEC0103_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0103_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0104-unencoded-literal-text.
        /// </summary>
        internal static string Analyzer_SEC0104_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0104_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using the raw Literal.Text method. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Literal controls are often found in HTML contexts, but can also appear in other contexts such as JavaScript, HTML Attribute, or URL. Fixing the vulnerability requires the appropriate Web Protection Library (aka AntiXSS) context-specific method to encode the data before settin [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Analyzer_SEC0104_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0104_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unencoded Literal.Text property value..
        /// </summary>
        internal static string Analyzer_SEC0104_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0104_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unencoded Literal Text.
        /// </summary>
        internal static string Analyzer_SEC0104_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0104_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0105-unencoded-label-text.
        /// </summary>
        internal static string Analyzer_SEC0105_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0105_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Data is written to the browser using the raw Label.Text method. This can result in Cross-Site Scripting (XSS) vulnerabilities if the data source is considered untrusted or dynamic (request parameters, database, web service, etc.).
        ///
        ///Label controls are often found in HTML contexts, but can also appear in other contexts such as JavaScript, HTML Attribute, or URL. Fixing the vulnerability requires the appropriate Web Protection Library (aka AntiXSS) context-specific method to encode the data before setting th [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Analyzer_SEC0105_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0105_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unencoded Label.Text property value..
        /// </summary>
        internal static string Analyzer_SEC0105_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0105_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unencoded Label Text.
        /// </summary>
        internal static string Analyzer_SEC0105_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0105_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0106-sql-injection-dynamic-linq-query.
        /// </summary>
        internal static string Analyzer_SEC0106_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0106_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concatenating untrusted data into a dynamic SQL string and calling vulnerable LINQ methods (e.g. ExecuteQuery, ExecuteCommand) can allow SQL Injection. To ensure calls to vulnerable LINQ methods are parameterized, pass parameters into the statement using the method’s second argument: params object[] parameters..
        /// </summary>
        internal static string Analyzer_SEC0106_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0106_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection - LINQ ExecuteQuery or ExecuteCommand method executes dynamic SQL without parameters..
        /// </summary>
        internal static string Analyzer_SEC0106_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0106_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection Dynamic LINQ Query.
        /// </summary>
        internal static string Analyzer_SEC0106_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0106_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0107-sql-injection-ado-net.
        /// </summary>
        internal static string Analyzer_SEC0107_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0107_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SQL Command communicates directly with the backend database without using an Object Relational Mapping (ORM) framework. There are several vulnerable methods (ExecuteReader, ExecuteNonQuery, ExecuteScalar) that allow dynamic SQL statements to be constructed and executed against the database. Ensure that calls to these methods do not concatenate untrusted data into dynamic SQL statements. Use parameter placeholders or stored procedures to prevent SQL Injection attacks..
        /// </summary>
        internal static string Analyzer_SEC0107_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0107_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection - ADO.NET method is passed a dynamic SQL statement..
        /// </summary>
        internal static string Analyzer_SEC0107_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0107_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection ADO .NET.
        /// </summary>
        internal static string Analyzer_SEC0107_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0107_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0108-sql-injection-dynamic-ef-query.
        /// </summary>
        internal static string Analyzer_SEC0108_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0108_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concatenating untrusted data into a dynamic SQL string and calling vulnerable Entity Framework (EF) methods (ExecuteSqlCommand, ExecuteSqlCommandAsync, SqlQuery) can allow SQL Injection. To ensure calls to vulnerable EF methods are parameterized, pass parameters into the statement using the  method’s second argument: params object[] parameters..
        /// </summary>
        internal static string Analyzer_SEC0108_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0108_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection - EF method executes dynamic SQL without parameters.
        /// </summary>
        internal static string Analyzer_SEC0108_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0108_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SQL Injection Dynamic EF Query.
        /// </summary>
        internal static string Analyzer_SEC0108_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0108_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0109-unvalidated-mvc-redirect.
        /// </summary>
        internal static string Analyzer_SEC0109_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0109_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Passing unvalidated redirect locations to the MVC Controller.Redirect method can allow attackers to send users to malicious web sites. This can allow attackers to perform phishing attacks and distribute malware to victims..
        /// </summary>
        internal static string Analyzer_SEC0109_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0109_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated redirect location is passed to the Controller.Redirect action..
        /// </summary>
        internal static string Analyzer_SEC0109_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0109_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated MVC Redirect.
        /// </summary>
        internal static string Analyzer_SEC0109_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0109_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0110-unvalidated-web-forms-redirect.
        /// </summary>
        internal static string Analyzer_SEC0110_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0110_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Passing unvalidated redirect locations to the Response.Redirect method can allow attackers to send users to malicious web sites. This can allow attackers to perform phishing attacks and distribute malware to victims..
        /// </summary>
        internal static string Analyzer_SEC0110_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0110_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated redirect location is passed to the Response.Redirect method..
        /// </summary>
        internal static string Analyzer_SEC0110_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0110_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated WebForms Redirect.
        /// </summary>
        internal static string Analyzer_SEC0110_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0110_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0111-path-tampering-mvc-file-result.
        /// </summary>
        internal static string Analyzer_SEC0111_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0111_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path traversal vulnerabilities occur when an application does not properly validate file paths for directory traversal (../) and other malicious characters. This can allow attackers to download, overwrite, or delete unauthorized files from the server. Ensure file paths are read from a trusted location, such as a static resource or configuration file. Do not send file paths in request parameters, which can be modified by an attacker..
        /// </summary>
        internal static string Analyzer_SEC0111_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0111_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated file path parameter is passed to the Controller {0} action, which can allow arbitrary file downloads from the server..
        /// </summary>
        internal static string Analyzer_SEC0111_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0111_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path Tampering File Path Result.
        /// </summary>
        internal static string Analyzer_SEC0111_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0111_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0112-path-tampering-unvalidated-file-path.
        /// </summary>
        internal static string Analyzer_SEC0112_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0112_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path traversal vulnerabilities occur when an application does not properly validate file paths for directory traversal (../) and other malicious characters. This can allow attackers to download, overwrite, or delete unauthorized files from the server. Ensure file paths are read from a trusted location, such as a static resource or configuration file. Do not send file paths in request parameters, which can be modified by an attacker..
        /// </summary>
        internal static string Analyzer_SEC0112_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0112_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated file paths are passed to a {0} API, which can allow unauthorized file system operations (e.g. read, write, delete) to be performed on unintended server files..
        /// </summary>
        internal static string Analyzer_SEC0112_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0112_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path Tampering Unvalidated File Path.
        /// </summary>
        internal static string Analyzer_SEC0112_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0112_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0113-certificate-validation-disabled.
        /// </summary>
        internal static string Analyzer_SEC0113_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0113_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overriding the default framework certificate validation method can allow man-in-the middle attacks against user’s running the application on insecure network connections..
        /// </summary>
        internal static string Analyzer_SEC0113_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0113_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The ServerCertificateValidationCallback method fails to properly validate the server&apos;s certificate..
        /// </summary>
        internal static string Analyzer_SEC0113_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0113_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Certificate Validation Disabled.
        /// </summary>
        internal static string Analyzer_SEC0113_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0113_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0114-ldap-injection-directory-entry.
        /// </summary>
        internal static string Analyzer_SEC0114_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0114_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection vulnerabilities occur when untrusted data is concatenated into a LDAP Path expression without properly escaping control characters. This can allow attackers to change the meaning of an LDAP query and gain access to resources for which they are not authorized. Fixing the vulnerability requires untrusted data to be encoded using the Web Protection Library (aka AntiXSS) LDAP encoding method Encoder.LdapDistinguishedNameEncode()..
        /// </summary>
        internal static string Analyzer_SEC0114_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0114_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is passed to the LDAP DirectoryEntry path expression..
        /// </summary>
        internal static string Analyzer_SEC0114_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0114_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection Directory Entry.
        /// </summary>
        internal static string Analyzer_SEC0114_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0114_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0115-insecure-random-number-generator.
        /// </summary>
        internal static string Analyzer_SEC0115_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0115_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to System.Random is a statistical random number generator that does not generate sufficiently random values for use in a security context. Generate values used in a security context (e.g., encryption keys, initialization vectors, random passwords, authentication tokens) using the System.Security.Cryptography.RNGCryptoServiceProvider..
        /// </summary>
        internal static string Analyzer_SEC0115_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0115_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to System.Random does not provide cryptographically random numbers. Consider using the System.Security.Cryptography.RNGCryptoServiceProvider for random values used in a security context..
        /// </summary>
        internal static string Analyzer_SEC0115_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0115_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Insecure Random Number Generator.
        /// </summary>
        internal static string Analyzer_SEC0115_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0115_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0116-path-tampering-unvalidated-file-path.
        /// </summary>
        internal static string Analyzer_SEC0116_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0116_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path traversal vulnerabilities occur when an application does not properly validate file paths for directory traversal (../) and other malicious characters. This can allow attackers to download, overwrite, or delete unauthorized files from the server. Ensure file paths are read from a trusted location, such as a static resource or configuration file. Do not send file paths in request parameters, which can be modified by an attacker..
        /// </summary>
        internal static string Analyzer_SEC0116_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0116_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unvalidated file paths are passed to a {0} API, which can allow unauthorized file system operations (e.g. read, write, delete) to be performed on unintended server files..
        /// </summary>
        internal static string Analyzer_SEC0116_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0116_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path Tampering Unvalidated File Path.
        /// </summary>
        internal static string Analyzer_SEC0116_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0116_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0117-ldap-injection-path-assignment.
        /// </summary>
        internal static string Analyzer_SEC0117_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0117_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection vulnerabilities occur when untrusted data is concatenated into a LDAP Path without properly escaping control characters. This can allow attackers to change the meaning of an LDAP query and gain access to resources for which they are not authorized. Fixing the vulnerability requires untrusted data to be encoded using the Web Protection Library (aka AntiXSS) LDAP encoding method  Encoder.LdapDistinguishedNameEncode()..
        /// </summary>
        internal static string Analyzer_SEC0117_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0117_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is assigned to the LDAP DirectoryEntry Path property..
        /// </summary>
        internal static string Analyzer_SEC0117_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0117_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection Path Assignment.
        /// </summary>
        internal static string Analyzer_SEC0117_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0117_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0118-ldap-injection-directory-searcher.
        /// </summary>
        internal static string Analyzer_SEC0118_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0118_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection vulnerabilities occur when untrusted data is concatenated into a LDAP Filter expression without properly escaping control characters. This can allow attackers to change the meaning of an LDAP query and gain access to resources for which they are not authorized. Fixing the vulnerability requires untrusted data to be encoded using the Web Protection Library (aka AntiXSS) LDAP filter encoding method Encoder.LdapFilterEncode()..
        /// </summary>
        internal static string Analyzer_SEC0118_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0118_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is passed to the LDAP DirectorySearcher filter expression..
        /// </summary>
        internal static string Analyzer_SEC0118_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0118_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection Directory Searcher.
        /// </summary>
        internal static string Analyzer_SEC0118_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0118_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0119-ldap-injection-directory-searcher.
        /// </summary>
        internal static string Analyzer_SEC0119_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0119_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection vulnerabilities occur when untrusted data is concatenated into a LDAP Filter without properly escaping control characters. This can allow attackers to change the meaning of an LDAP query and gain access to resources for which they are not authorized. Fixing the vulnerability requires untrusted data to be encoded using the Web Protection Library (aka AntiXSS) LDAP filter encoding method Encoder.LdapFilterEncode()..
        /// </summary>
        internal static string Analyzer_SEC0119_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0119_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Untrusted data is passed to the LDAP DirectoryEntry Filter property.
        /// </summary>
        internal static string Analyzer_SEC0119_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0119_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to LDAP Injection Filter Assignment.
        /// </summary>
        internal static string Analyzer_SEC0119_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0119_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0120-missing-authorize-attribute.
        /// </summary>
        internal static string Analyzer_SEC0120_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0120_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing Authorization occurs when an application does not properly verify an authenticated user’s access to functionality, data, or resources. In many cases, applications do not check  policy, claim, or role-based access control rules during a request. This can allow attackers to invoke privileged functionality, such as changing their role or directly browsing to an administrative interface in the application.
        ///
        ///Restricting access to ASP.NET MVC, Web API, and .NET Core Controllers and Actions is achieved u [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Analyzer_SEC0120_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0120_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Action is missing the Authorization attribute and can be invoked by anonymous users..
        /// </summary>
        internal static string Analyzer_SEC0120_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0120_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Missing Authorization Attribute.
        /// </summary>
        internal static string Analyzer_SEC0120_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0120_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0121-cors-any-origin-wildcard.
        /// </summary>
        internal static string Analyzer_SEC0121_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0121_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cross-Origin Resource Sharing (CORS) allows a service to disable the browser’s Same-origin policy, which prevents scripts on an attacker-controlled domain from accessing resources and data hosted on a different domain. The CORS Access-Control-Allow-Origin HTTP header specifies the domain with permission to invoke a cross-origin service and view the response data. Configuring the Access-Control-Allow-Origin header with a wildcard (*) can allow code running on an attacker-controlled domain to view responses c [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Analyzer_SEC0121_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0121_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not set the CORS Access-Control-Allow-Origin header to a wildcard (*)..
        /// </summary>
        internal static string Analyzer_SEC0121_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0121_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CORS Allow Origin Wildcard.
        /// </summary>
        internal static string Analyzer_SEC0121_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0121_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to sec0122-jwt-signature-validation-disabled.
        /// </summary>
        internal static string Analyzer_SEC0122_Anchor {
            get {
                return ResourceManager.GetString("Analyzer_SEC0122_Anchor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The JSON Web Tokens (JWT) header and payload values are base64 encoded, which can be decoded, tampered, and replayed to gain access to protected resources. Web service APIs relying on JSON Web Tokens (JWT) for authentication and authorization must sign each JWT with a private key or secret. Each web service endpoint must require JWT signature validation prior to decoding and using the token to access protected resources.
        ///
        ///In ASP.NET Core, configure the Authentication service’s JwtBearer options to require [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Analyzer_SEC0122_Description {
            get {
                return ResourceManager.GetString("Analyzer_SEC0122_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Configure the JwtBearer options to require signed tokens..
        /// </summary>
        internal static string Analyzer_SEC0122_MessageFormat {
            get {
                return ResourceManager.GetString("Analyzer_SEC0122_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to JWT Signature Validation Disabled.
        /// </summary>
        internal static string Analyzer_SEC0122_Title {
            get {
                return ResourceManager.GetString("Analyzer_SEC0122_Title", resourceCulture);
            }
        }
    }
}
